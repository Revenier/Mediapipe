import pandas as pd
import numpy as np
import pickle
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import normalize
from sklearn.metrics.pairwise import cosine_similarity

def train_and_save():
    # Load CSV
    landmarks = pd.read_csv('dataset/landmarks.csv')
    labels = pd.read_csv('dataset/labels.csv')

    # Merge data
    data = pd.merge(landmarks, labels, on='vid_id')
    X = data.drop(columns=['vid_id', 'frame_order', 'class'])
    y = data['class']

    # Normalize for cosine similarity
    X_normalized = normalize(X.values, axis=1)

    # Encode labels
    le = LabelEncoder()
    y_encoded = le.fit_transform(y)

    # Save as .pkl
    dataset = {
        'X': X_normalized,
        'y': y_encoded,
        'label_encoder': le
    }
    with open('posture_cosine.pkl', 'wb') as f:
        pickle.dump(dataset, f)
    print("âœ… Model saved to posture_cosine.pkl")

def predict_from_input(input_vector):
    # Load model
    with open('posture_cosine.pkl', 'rb') as f:
        data = pickle.load(f)

    X_train = data['X']
    y_train = data['y']
    label_encoder = data['label_encoder']

    # Normalize input vector to match training data
    input_vector = np.array(input_vector).reshape(1, -1)
    input_normalized = normalize(input_vector, axis=1)

    # Cosine similarity
    similarity_scores = cosine_similarity(input_normalized, X_train)
    # best_idx = np.argmax(similarity_scores)
    # predicted_label = y_train[best_idx]
    k = 5  # try top 5 most similar
    top_k_idx = np.argsort(similarity_scores[0])[-k:]
    top_k_labels = y_train[top_k_idx]

    # Majority vote
    predicted_label = np.bincount(top_k_labels).argmax()


    result = label_encoder.inverse_transform([predicted_label])[0]
    print(f"ðŸ“Œ Predicted posture: {result}")
    return result

# ========== post data dari sini ==========

from flask import Flask, request, jsonify
from flask_cors import CORS
import joblib
import numpy as np

app = Flask(__name__)
CORS(app) 
@app.route('/predict', methods=['POST'])
def predict():
    try:
        data = request.get_json()

        # jumping jack
        # raw_landmarks = [0.913, -50.84, -43.25, 1.424, -53.08, -39.33, 1.907, -53.02, -39.32, 2.273, -53.00, -39.33, -0.094, -52.94, -39.76, -0.683, -52.80, -39.76, -1.266, -52.64, -39.76, 2.746, -51.46, -21.70, -2.120, -51.09, -23.31, 1.903, -47.89, -36.95, 0.115, -47.71, -37.48, 7.040, -40.22, -15.23, -5.685, -39.56, -20.99, 13.205, -54.57, -21.75, -12.464, -56.10, -33.85, 12.841, -73.42, -31.81, -11.028, -75.08, -41.47, 12.895, -76.95, -36.29, -10.538, -79.87, -47.27, 12.213, -77.70, -36.52, -9.971, -79.79, -44.75, 12.055, -76.39, -32.88, -9.984, -78.25, -41.47, 4.500, -0.34, 2.64, -4.480, 0.36, -2.44, 11.432, 22.27, -0.88, -6.969, 28.99, -8.25, 16.730, 40.89, 35.19, -14.479, 48.99, 20.61, 16.640, 43.83, 37.89, -15.359, 50.63, 22.59, 19.034, 50.55, 19.71, -14.556, 57.14, 2.79]

        # push up
        # raw_landmarks = [0.48121005296707153, 0.6747843623161316, -2.447263240814209, 0.5315266847610474, 0.574421226978302, -2.390549898147583, 0.5643851161003113, 0.5674421191215515, -2.390531063079834, 0.5916626453399658, 0.5622946619987488, -2.392540454864502, 0.4350188374519348, 0.5878617763519287, -2.379284381866455, 0.4093063771724701, 0.5906034111976624, -2.379329204559326, 0.3859052360057831, 0.5936904549598694, -2.3816752433776855, 0.6451863050460815, 0.5760282874107361, -1.7391208410263062, 0.37957149744033813, 0.613665759563446, -1.6802221536636353, 0.5562983155250549, 0.768756091594696, -2.168328046798706, 0.446087509393692, 0.7814559936523438, -2.1547014713287354, 0.897433876991272, 0.9848420023918152, -1.1115385293960571, 0.22372905910015106, 1.0027906894683838, -0.9806157350540161, 1.1856918334960938, 1.4132179021835327, -1.3539308309555054, 0.09906371682882309, 1.5030152797698975, -0.4306906759738922, 0.9959349632263184, 1.4609495401382446, -2.0149855613708496, 0.2056393176317215, 1.7834821939468384, -0.6638708710670471, 0.956013560295105, 1.5213220119476318, -2.1659908294677734, 0.24038751423358917, 1.9183323383331299, -0.7553867101669312, 0.9074621200561523, 1.4460116624832153, -2.1617236137390137, 0.2567214071750641, 1.8650397062301636, -0.7960097193717957, 0.9091817140579224, 1.4232356548309326, -2.0317635536193848, 0.2558407187461853, 1.8124433755874634, -0.6901748776435852, 0.8031676411628723, 2.1156694889068604, -0.1563624143600464, 0.3782728314399719, 2.120152235031128, 0.16353821754455566, 0.7946868538856506, 2.9163777828216553, -0.39951735734939575, 0.41531285643577576, 2.8784191608428955, -0.3844040334224701, 0.8373422622680664, 3.727404832839966, 0.414510577917099, 0.46270933747291565, 3.7224957942962646, 0.2116076499223709, 0.8621425628662109, 3.861377239227295, 0.44427886605262756, 0.4703764021396637, 3.8577492237091064, 0.23229913413524628, 0.7761837840080261, 4.001626491546631, -0.49837636947631836, 0.5018725395202637, 3.9975955486297607, -0.781531572341919]

        # pull up
        # raw_landmarks = [0.0, -30.0, -20.0, 0.5, -31.0, -19.0, -0.5, -31.0, -19.0, 1.0, -31.5, -18.0, -1.0, -31.5, -18.0, 3.0, -35.0, -20.0, -3.0, -35.0, -20.0, 4.0, -40.0, -15.0, -4.0, -40.0, -15.0, 5.0, -45.0, -10.0, -5.0, -45.0, -10.0, 6.0, -60.0, -25.0, -6.0, -60.0, -25.0, 6.5, -80.0, -30.0, -6.5, -80.0, -30.0, 7.0, -100.0, -30.0, -7.0, -100.0, -30.0, 7.2, -102.0, -30.0, -7.2, -102.0, -30.0, 7.0, -104.0, -30.0, -7.0, -104.0, -30.0, 7.0, -103.0, -30.0, -7.0, -103.0, -30.0, 6.5, -100.0, -29.5, -6.5, -100.0, -29.5, 0.0, -60.0, -25.0, 0.0, -65.0, -20.0, 0.0, -70.0, -15.0, 0.0, -72.0, -10.0, 1.5, -45.0, -12.0, -1.5, -45.0, -12.0, 0.0, -28.0, -20.0, 0.0, -27.0, -21.0]
        
        # real data pull up
        # [0.5019057989120483, 0.46148595213890076, -0.09466342628002167, 0.5158917307853699, 0.44353410601615906, -0.05565786361694336, 0.5249722599983215, 0.4463438093662262, -0.0556713342666626, 0.5327696800231934, 0.44773563742637634, -0.055795155465602875, 0.49096089601516724, 0.4446251690387726, -0.04860556870698929, 0.48286595940589905, 0.44554784893989563, -0.04868938773870468, 0.4745677411556244, 0.44648823142051697, -0.049290381371974945, 0.5479212999343872, 0.48040473461151123, 0.12724685668945312, 0.46564850211143494, 0.477461040019989, 0.1572980135679245, 0.5201159715652466, 0.5010895729064941, -0.024906381964683533, 0.5021127462387085, 0.47086092829704285, -0.016685325652360916, 0.6282221078872681, 0.6088173985481262, 0.08987743407487869, 0.4009544253349304, 0.6424736380577087, 0.19493737816810608, 0.7190473675727844, 0.6121340394020081, -0.1574881374835968, 0.34606221318244934, 0.6554052829742432, 0.06380240619182587, 0.626056969165802, 0.5988034605979919, -0.33679771423339844, 0.4244415760040283, 0.5794891119003296, 0.032922908663749695, 0.6142897009849548, 0.6092977523803711, -0.38027068972587585, 0.4482228755950928, 0.5727909207344055, -0.007308562286198139, 0.5992856025695801, 0.6057363748550415, -0.31400203704833984, 0.4535598158836365, 0.5690274834632874, 0.019050784409046173, 0.6016644835472107, 0.6093479990959167, -0.4051424562931061, 0.4468693137168884, 0.5817860960960388, 0.033524949103593826, 0.6182490587234497, 1.1464639902114868, -0.07663942873477936, 0.4662477970123291, 1.1610281467437744, 0.07743027061223984, 0.6411617398262024, 1.3611888885498047, -0.09484817832708359, 0.42870229482650757, 1.540056824684143, 0.030292758718132973, 0.6797484755516052, 1.6678146123886108, 0.288749635219574, 0.5010958909988403, 1.7454791069030762, 0.24464182555675507, 0.6885700225830078, 1.7186238765716553, 0.2706069350242615, 0.5313962697982788, 1.7903976440429688, 0.2582627236843109, 0.6959277391433716, 1.7373311519622803, 0.012707972899079323, 0.5077959299087524, 1.879387378692627, 0.03694099560379982]
        raw_landmarks = data['landmarks']
        # print("Number of landmarks received:", len(raw_landmarks))
        print(raw_landmarks)

        # Validate input length
        if len(raw_landmarks) < 99:
            return jsonify({'error': 'Not enough landmark data. Expected at least 99 values.'}), 400

        # Predict posture using your cosine similarity model
        result = predict_from_input(raw_landmarks)

        # Return the result as JSON
        return jsonify({'predicted_posture': result})

    except Exception as e:
        return jsonify({'error': str(e)}), 500


# ========== jalanin app nya ==========
if __name__ == "__main__":
    app.run(debug=True)
    